===============================
📘 HEAP DATA STRUCTURE NOTES
===============================

🧠 What is a Heap?
-------------------
A Heap is a special **complete binary tree** that satisfies the **heap property**:
- In a **Max-Heap**: Parent ≥ Children
- In a **Min-Heap**: Parent ≤ Children

Stored commonly as an array for efficiency.

📦 Properties of Heap:
-----------------------
1. Complete Binary Tree
   - All levels filled except possibly the last
   - Last level is filled left to right
2. Heap Property
   - Max-Heap: Parent >= Children
   - Min-Heap: Parent <= Children

🧩 Types of Heaps:
-------------------
- Max-Heap: Root is the maximum value
- Min-Heap: Root is the minimum value

🛠️ Common Heap Operations:
----------------------------
- insert(value): Adds a value and reorders heap
- peek(): Returns the root value without removing
- extract_min() or extract_max(): Removes the root and heapifies
- heapify(): Converts array into a valid heap

📐 Heap as Array (Index Formulas):
-----------------------------------
For node at index i:
- Parent       = (i - 1) // 2
- Left Child   = 2 * i + 1
- Right Child  = 2 * i + 2

🧪 Min-Heap Example:
---------------------
         2
       /   \
      3     4
     / \
    5   10

Array: [2, 3, 4, 5, 10]

⏱️ Time & Space Complexity:
----------------------------
| Operation      | Time Complexity |
|----------------|-----------------|
| Insert         | O(log n)        |
| Remove Root    | O(log n)        |
| Peek           | O(1)            |
| Build Heap     | O(n)            |

📊 Applications of Heap:
-------------------------
- Priority Queues
- Dijkstra's Algorithm (Shortest Path)
- Heap Sort
- CPU Scheduling
- Median maintenance (with 2 heaps)

🚀 Heap Sort Overview (Using Max-Heap):
----------------------------------------
1. Build a Max-Heap
2. Swap root with last element
3. Shrink heap size by 1
4. Heapify the root
5. Repeat until sorted

Time Complexity: O(n log n)

===============================
# ------------------------------------------
# 🔼 HEAPIFY-UP (a.k.a. Bubble Up or Sift Up)
# ------------------------------------------
# Used after inserting a new element at the end of the heap
# It ensures the heap property is maintained by moving the new element up

def heapify_up(index):
    parent_index = (index - 1) // 2
    if index > 0 and heap[index] > heap[parent_index]:  # For Max Heap
        heap[index], heap[parent_index] = heap[parent_index], heap[index]
        heapify_up(parent_index)

# ------------------------------------------
# 🔽 HEAPIFY-DOWN (a.k.a. Bubble Down or Sift Down)
# ------------------------------------------
# Used after removing the root (usually the max or min element)
# It ensures the heap property is restored by moving the element down

def heapify_down(index):
    left = 2 * index + 1
    right = 2 * index + 2
    largest = index

    # Check if left child exists and is greater than current
    if left < len(heap) and heap[left] > heap[largest]:
        largest = left

    # Check if right child exists and is greater than current
    if right < len(heap) and heap[right] > heap[largest]:
        largest = right

    # If largest is not the current index, swap and recurse
    if largest != index:
        heap[index], heap[largest] = heap[largest], heap[index]
        heapify_down(largest)
